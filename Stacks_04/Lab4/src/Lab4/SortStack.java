package Lab4;/** * A class that provides methods for sorting a stack of * Comparable objects, placing the smallest at the top of the stack. * * @author ORI WEISS * @version 02/13/2018 */import java.util.*;public class SortStack<T extends Comparable<? super T>>{    private Stack<T> stack;    public SortStack()    {        this.stack = new Stack<>();    }    /**     * Sorts a stack.     *     * @return a sorted stack     */    public Stack<T> sort()    {        // TODO PROJECT #6 Part1        // this.stack represents the original stack        Stack<T> destination = new Stack<>();        Stack<T> temp = new Stack<>();        T topO;        T topD;        T object;        if(!this.stack.isEmpty()){            object = destination.push(this.stack.pop());            System.out.println("push "+ object + " from original to destination");        }        while(!this.stack.isEmpty()){            topO = this.stack.peek();            topD = destination.peek();            boolean print = true;            while(!destination.isEmpty() && topO.compareTo(destination.peek()) > 0 ){                object = temp.push(destination.pop());                if (print) {                    System.out.println("Moving entries from destination to temp");                }                System.out.println("--> push " + object + " from destination to temp");                print = false;            }            object = destination.push(this.stack.pop());            System.out.println("push " + object + " to destination");            print = true;            while(!temp.isEmpty()) {                object = destination.push(temp.pop());                if (print) {                    System.out.println("Moving entries from temp to destination");                }                print = false;                System.out.println("--> push " + object + " from temp to destination");            }        }        return destination;    }    /**     * Sorts a stack. (revised version)     *     * @return a sorted stack     */    public Stack<T> sortRevised()    {        // TODO PROJECT #6 Part2        // this.stack represents the original stack        Stack<T> destination = new Stack<>();        Stack<T> temp = new Stack<>();        T object;        boolean print = true;        if(!this.stack.isEmpty()){            object = destination.push(this.stack.pop());            System.out.println("push " +object+ " from original to destination" );        }        while(!this.stack.isEmpty()){            while(!destination.isEmpty() && this.stack.peek().compareTo(destination.peek()) > 0){                object = temp.push(destination.pop());                if(print){                    System.out.println("moving entries from destination to temp");                    print = false;                }                System.out.println("push " + object + " from destination to temp");            }            print = true;            while(!temp.isEmpty() && this.stack.peek().compareTo(temp.peek()) < 0){                object = destination.push(temp.pop());                if(print){                    System.out.println("moving entries from destination to temp");                    print = false;                }                System.out.println("push " + object + " from temp to destination");            }            destination.push(this.stack.pop());        }        print = true;        while(!temp.isEmpty()){            object = destination.push(temp.pop());            if(print){                System.out.println("moving entries from temp to destination");                print = false;            }            System.out.println("push " + object + " from temp to destination");        }        return destination;    }    public void setStack(T... elements)    {        this.stack.clear();        System.out.println("Setting the original stack to:");        for (int i = 0; i < elements.length; i++)        {            this.stack.push(elements[i]);            System.out.print(elements[i] + " ");        }        System.out.println();    }    public static void main(String[] args)    {        SortStack sc = new SortStack();        sc.setStack("03", "09", "01", "04", "06", "05", "07", "08", "00", "02");        System.out.println("\n***Calling sort method***");        Stack<String> sortedStack = sc.sort();        System.out.println("\nStack should be sorted (with sort()) ....");        while (!sortedStack.isEmpty())            System.out.print(sortedStack.pop() + " ");        System.out.println();        System.out.println("\n===================================");        System.out.println("\nTesting the revised method");        sc.setStack("03", "09", "01", "04", "06", "05", "07", "08", "00", "02");        System.out.println("\n***Calling sortRevised method***");        sortedStack = sc.sortRevised();        System.out.println("\nStack should be sorted (with sortRevised()) ....");        while (!sortedStack.isEmpty())            System.out.print(sortedStack.pop() + " ");        System.out.println();    } // end main} // end SortStack