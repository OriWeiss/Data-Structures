package Lab14b;import java.util.*;import java.util.concurrent.LinkedBlockingQueue;/** * A class that creates a minimum spanning tree * for a given graph * The graph is represented by adjacency matrix * * @author Anna Bieszczad * @version 5/1/2018 */public class MinimumSpanningTree{    // The matrix below represents the graph from the example provided in the lab description    // The instructor used this hardcoded matrix for testing,    // your code however must generate the matrix randomly//    private int[][] adjMatrix = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},//            {0, 0, 0, 3, 1, 0, 0, 0, 0, 0, 2},//            {0, 0, 0, 4, 0, 0, 10, 0, 0, 0, 0},//            {0, 3, 4, 0, 3, 5, 0, 0, 0, 0, 0},//            {0, 1, 0, 3, 0, 2, 0, 0, 0, 0, 0},//            {0, 0, 0, 5, 2, 0, 6, 0, 1, 0, 0},//            {0, 0, 10, 0, 0, 6, 0, 9, 10, 0, 0},//            {0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0},//            {0, 0, 0, 0, 0, 1, 10, 0, 0, 8, 0},//            {0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 10},//            {0, 2, 0, 0, 0, 0, 0, 0, 0, 10, 0}};    private int[][] adjMatrix;    private int[][] minimumSpanningTree;    private int numberOfNodes;    final int GRAYED_OUT = -1;    final int MARKED_FOR_CHECKING = -1;    final int PERCENT100 = 100;    public MinimumSpanningTree(int numberOfNodes, int probability)    {   this.numberOfNodes = numberOfNodes;        this.adjMatrix= new int [this.numberOfNodes +1][this.numberOfNodes+1];        this.minimumSpanningTree = new int [this.numberOfNodes +1][this.numberOfNodes+1];        Random randomRandy = new Random(101);        for (int i = 1; i < this.numberOfNodes ; i++) { //i = row            for (int j = i+1; j < this.numberOfNodes+1; j++) { //j = column                int randomRon = randomRandy.nextInt(this.PERCENT100);                if(randomRon <= probability){                    int weight = randomRandy.nextInt(this.numberOfNodes)+ 1;                    this.adjMatrix[i][j] = weight;                    this.adjMatrix[j][i]= weight;                }            }        }        adjMatrix = new int[][]{{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},           {0, 0, 0, 3, 1, 0, 0, 0, 0, 0, 2},            {0, 0, 0, 4, 0, 0, 10, 0, 0, 0, 0},            {0, 3, 4, 0, 3, 5, 0, 0, 0, 0, 0},            {0, 1, 0, 3, 0, 2, 0, 0, 0, 0, 0},            {0, 0, 0, 5, 2, 0, 6, 0, 1, 0, 0},            {0, 0, 10, 0, 0, 6, 0, 9, 10, 0, 0},            {0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0},            {0, 0, 0, 0, 0, 1, 10, 0, 0, 8, 0},            {0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 10},            {0, 2, 0, 0, 0, 0, 0, 0, 0, 10, 0}};//for testing        }        //max value for weights =/ number of nodes        //minimum value for weights = 1        //TODO Lab14b #1.1    public boolean isConnected()    {        // TODO Lab14b #1.4        //set 0 row and 0 column to 0        for (int i = 0; i < this.numberOfNodes+1; i++) {            this.adjMatrix[i][0] = 0;            this.adjMatrix[0][i] = 0;        }//add to a counter and if the counter is equal to the number of nodes it is connected        Integer counter = 0;        Queue<Integer> vertexQueue =                new LinkedBlockingQueue<Integer>();        int originVertex = 1;        this.adjMatrix[0][1] = this.GRAYED_OUT;        counter++;    // enqueue vertex label        vertexQueue.offer(originVertex); // enqueue vertex        while (!vertexQueue.isEmpty())        {            Integer frontVertex = vertexQueue.poll();            for (int i = 1; i < this.numberOfNodes +1 ; i++) {                if(this.adjMatrix[frontVertex][i] !=0 && this.adjMatrix[0][i] != this.GRAYED_OUT){                    this.adjMatrix[0][i] = this.GRAYED_OUT;                    counter++;                    vertexQueue.offer(i);                }            }        }        // utilize BFS algorithm        return this.numberOfNodes == counter;    }    public boolean minimumSpanTreeCheckForCycle()    {        boolean[] visited = new boolean[this.numberOfNodes + 1];        return hasCycle(this.minimumSpanningTree, 1, visited);    }    public boolean connectedGraphCheckForCycle()    {        boolean[] visited = new boolean[this.numberOfNodes + 1];        return hasCycle(this.adjMatrix, 1, visited);    }    private boolean hasCycle(int[][] graphToCheck, int start, boolean[] visited)    {        // TODO Lab14b #1.5        visited[start] = true;        for (int j = start + 1; j <= this.numberOfNodes; j++) {             //if start and j are connected return true if either j was visited or recursive call starting with j returns true            if(graphToCheck[start][j] != 0 &&(visited[j] == true || hasCycle(graphToCheck, j ,visited))){                    return true;            }        }        return false;    }    public void calculateMinimumSpanningTree()    {        // TODO Lab14b #1.3        //reset the 0 rows and columns        for (int i = 0; i < this.numberOfNodes+1; i++) {            this.adjMatrix[i][0] = 0;            this.adjMatrix[0][i] = 0;        }        this.adjMatrix[1][0] = this.MARKED_FOR_CHECKING;//put a mark beside the first row        this.adjMatrix[0][1] = this.GRAYED_OUT; // // gray-out the first column        for (int i = 0; i < this.numberOfNodes; i++) {            Element smallest = findSmallestInMarkedRows();            this.minimumSpanningTree[smallest.column][smallest.row]= smallest.value;            this.minimumSpanningTree[smallest.row][smallest.column] = smallest.value;            //mark the row grey out the column            this.adjMatrix[smallest.column][0] = this.MARKED_FOR_CHECKING;            this.adjMatrix[0][smallest.column] = this.GRAYED_OUT;        }//row parent        //column child        // utilize findSmallestInMarkedRows method    }    private Element findSmallestInMarkedRows()    {        // TODO Lab14b #1.2        int smallest = this.numberOfNodes;        int row = 0;        int col = 0;        for (int i = 1; i < this.numberOfNodes; i++) { // i= row j = column            //System.out.println("VV");            if(this.adjMatrix[i][0] == this.MARKED_FOR_CHECKING){                //System.out.println("HERE");                for (int j = 1; j <= this.numberOfNodes; j++) {                    if(this.adjMatrix[0][j] !=this.GRAYED_OUT) {                        //System.out.println("NOW HERE");                        if (smallest > this.adjMatrix[i][j] && this.adjMatrix[i][j] != 0) {                            row = i;                            col = j;                            smallest = this.adjMatrix[i][j];                            //System.out.println("row= " + row + "; col= " + col + "; smallest= " + smallest);                        }                    }                }            }        }        return new Element(row, col, smallest);    }    public void displayGraph()    {        System.out.println("***** GENERATED GRAPH *****");        displayMatrix(this.adjMatrix);    }    public void displayMinimumSpanningTree()    {        System.out.println("\n\n***** MINIMUM SPANNING TREE FOR THE ABOVE GRAPH *****");        displayMatrix(this.minimumSpanningTree);    }    private void displayMatrix(int[][] matrix)    {        System.out.print("     ");        for (int c = 1; c <= this.numberOfNodes; c++)        {            System.out.printf("[%1$2d]", c);        }        System.out.println();        for (int r = 1; r <= this.numberOfNodes; r++)        {            //System.out.print(r + " ");            System.out.printf("[%1$2d]", r);            for (int c = 1; c <= this.numberOfNodes; c++)            {                if (matrix[r][c] > 0)                    System.out.printf("%1$4d", matrix[r][c]);                else                    System.out.printf("%1$4s", " ");            }            System.out.println();        }    }    public static void main(String[] args)    {        System.out.println("How many nodes in your graph?");        Scanner scan = new Scanner(System.in);        int numberOfNodes = scan.nextInt();        System.out.println("Probability of edge? (type 70 for 70%)");        int probability = scan.nextInt();        MinimumSpanningTree graph = new MinimumSpanningTree(numberOfNodes, probability);        graph.displayGraph();        if (graph.isConnected())        {            if (graph.connectedGraphCheckForCycle())                System.out.println("\nThe graph has cycles.");            else                System.out.println("\nThe graph is acyclic.");            graph.calculateMinimumSpanningTree();            graph.displayMinimumSpanningTree();            if (graph.minimumSpanTreeCheckForCycle())                System.out.println("\nThe minimum spanning tree has cycles.");            else                System.out.println("\nThe minimum spanning tree is acyclic.");        }        else            System.out.println("The graph is not connected, the minimum spanning tree will not be calculated");    } // end main    private class Element    {        private int row;        private int column;        private int value;        public Element(int row, int column, int value)        {            this.row = row;            this.column = column;            this.value = value;        }    }}